---
name: rotech-database
description: Prisma database schema, API routes en data modellen voor Ro-Tech
globs:
  - prisma/**/*
  - src/app/api/**/*
  - src/lib/prisma.ts
  - src/lib/auth.ts
  - src/lib/stripe.ts
---

# üóÑÔ∏è RO-TECH DATABASE & API

Prisma ORM, database modellen en API routes voor het Ro-Tech platform.

---

## üìã OVERZICHT

### Database

| Aspect | Details |
|--------|---------|
| ORM | Prisma 6+ |
| Development | SQLite (`dev.db`) |
| Production | PostgreSQL (Vercel) |
| Auth | NextAuth v5 (beta) |
| Payments | Stripe |

### Modellen

| Model | Doel |
|-------|------|
| `User` | Klanten & admins |
| `Session` | Auth sessies |
| `Subscription` | Onderhoudsabonnementen |
| `Product` | Klant websites/apps |
| `SupportTicket` | Support tickets |
| `Invoice` | Facturen |
| `AdminAuditLog` | Admin acties log |

---

## üìÅ BESTANDSSTRUCTUUR

```
prisma/
‚îú‚îÄ‚îÄ schema.prisma              # Database schema
‚îú‚îÄ‚îÄ dev.db                     # SQLite development database
‚îî‚îÄ‚îÄ seed.ts                    # Database seeding

src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ prisma.ts              # Prisma client singleton
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts                # Auth utilities
‚îÇ   ‚îú‚îÄ‚îÄ stripe.ts              # Stripe client
‚îÇ   ‚îú‚îÄ‚îÄ api-auth.ts            # API authentication helpers
‚îÇ   ‚îî‚îÄ‚îÄ rate-limit.ts          # Rate limiting
‚îÇ
‚îî‚îÄ‚îÄ app/api/
    ‚îú‚îÄ‚îÄ auth/
    ‚îÇ   ‚îú‚îÄ‚îÄ [...nextauth]/     # NextAuth endpoints
    ‚îÇ   ‚îî‚îÄ‚îÄ register/          # User registration
    ‚îÇ
    ‚îú‚îÄ‚îÄ contact/               # Contact form
    ‚îú‚îÄ‚îÄ offerte/               # Quote requests
    ‚îú‚îÄ‚îÄ quote-request/         # Quote builder
    ‚îÇ
    ‚îú‚îÄ‚îÄ portal/                # Portal API (auth required)
    ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
    ‚îÇ   ‚îú‚îÄ‚îÄ profile/
    ‚îÇ   ‚îú‚îÄ‚îÄ tickets/
    ‚îÇ   ‚îî‚îÄ‚îÄ products/
    ‚îÇ
    ‚îú‚îÄ‚îÄ admin/                 # Admin API (admin only)
    ‚îÇ   ‚îú‚îÄ‚îÄ users/
    ‚îÇ   ‚îú‚îÄ‚îÄ subscriptions/
    ‚îÇ   ‚îú‚îÄ‚îÄ forms/
    ‚îÇ   ‚îî‚îÄ‚îÄ work-orders/
    ‚îÇ
    ‚îú‚îÄ‚îÄ payments/              # Stripe payments
    ‚îÇ   ‚îú‚îÄ‚îÄ create/
    ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
    ‚îÇ
    ‚îú‚îÄ‚îÄ subscriptions/         # Subscription management
    ‚îÇ   ‚îú‚îÄ‚îÄ create/
    ‚îÇ   ‚îî‚îÄ‚îÄ webhook/
    ‚îÇ
    ‚îú‚îÄ‚îÄ support/               # Support tickets
    ‚îÇ   ‚îî‚îÄ‚îÄ tickets/
    ‚îÇ
    ‚îî‚îÄ‚îÄ v1/                    # Versioned public API
        ‚îî‚îÄ‚îÄ health/
```

---

## üóÉÔ∏è PRISMA SCHEMA

### User & Authentication

```prisma
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String    // Hashed with bcrypt
  name          String
  phone         String?
  
  // Company info
  companyName   String?
  kvkNumber     String?
  vatNumber     String?
  
  // Address
  street        String?
  houseNumber   String?
  postalCode    String?
  city          String?
  country       String    @default("Nederland")
  
  // Status
  emailVerified DateTime?
  isActive      Boolean   @default(true)
  role          String    @default("customer") // customer, admin, super_admin
  permissions   String?   // JSON: ["users.read", "subscriptions.manage"]
  
  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?
  
  // Relations
  subscriptions Subscription[]
  products      Product[]
  supportTickets SupportTicket[]
  invoices      Invoice[]
  sessions      Session[]
  
  @@index([email])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  
  @@index([userId])
}
```

### Subscriptions

```prisma
model Subscription {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Plan details
  planType        String   // basis, business, premium
  planName        String
  monthlyPrice    Float
  
  // Stripe
  stripeSubscriptionId String? @unique
  stripeCustomerId     String?
  stripePriceId        String?
  
  // Status
  status          String   @default("active") // active, paused, cancelled, past_due
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean @default(false)
  
  // Usage
  hoursIncluded   Float    @default(0)
  hoursUsed       Float    @default(0)
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  cancelledAt     DateTime?
  
  // Relations
  product         Product? @relation(fields: [productId], references: [id])
  productId       String?
  usageLogs       UsageLog[]
  
  @@index([userId])
  @@index([status])
}

model UsageLog {
  id             String   @id @default(cuid())
  subscriptionId String
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  description    String
  hours          Float
  date           DateTime @default(now())
  category       String   // update, bugfix, feature, support
  
  createdAt      DateTime @default(now())
  
  @@index([subscriptionId])
}
```

### Products

```prisma
model Product {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  type            String   // website, webshop, webapp, api
  description     String?
  
  domain          String?
  hostingProvider String?
  techStack       String?  // JSON
  
  status          String   @default("active") // development, active, maintenance, archived
  launchDate      DateTime?
  
  originalQuoteId String?
  projectValue    Float?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  subscriptions   Subscription[]
  supportTickets  SupportTicket[]
  statusUpdates   StatusUpdate[]
  
  @@index([userId])
  @@index([status])
}
```

### Support Tickets

```prisma
model SupportTicket {
  id            String   @id @default(cuid())
  ticketNumber  String   @unique // RT-2024-001
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  productId     String?
  product       Product? @relation(fields: [productId], references: [id])
  
  subject       String
  description   String
  category      String   // general, technical, billing, feature-request
  priority      String   @default("medium") // low, medium, high, urgent
  
  status        String   @default("open") // open, in_progress, waiting_customer, resolved, closed
  
  adminPortalId String?
  syncedAt      DateTime?
  
  resolution    String?
  resolvedAt    DateTime?
  resolvedBy    String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  messages      TicketMessage[]
  
  @@index([userId])
  @@index([status])
  @@index([ticketNumber])
}

model TicketMessage {
  id           String   @id @default(cuid())
  ticketId     String
  ticket       SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  senderType   String   // customer, support, ai, system
  senderName   String
  senderId     String?
  
  message      String
  attachments  String?  // JSON array of URLs
  
  isRead       Boolean  @default(false)
  readAt       DateTime?
  
  createdAt    DateTime @default(now())
  
  @@index([ticketId])
}
```

### Invoices & Audit

```prisma
model Invoice {
  id              String   @id @default(cuid())
  invoiceNumber   String   @unique // RT-INV-2024-001
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  stripeInvoiceId String?  @unique
  
  amount          Float
  tax             Float
  status          String   // draft, open, paid, void, uncollectible
  
  description     String?
  dueDate         DateTime?
  paidAt          DateTime?
  pdfUrl          String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([status])
}

model AdminAuditLog {
  id          String   @id @default(cuid())
  adminId     String
  adminEmail  String
  
  action      String   // user.create, subscription.update, etc.
  targetType  String   // user, subscription, product, ticket, invoice
  targetId    String?
  
  before      String?  // JSON snapshot
  after       String?  // JSON snapshot
  
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime @default(now())
  
  @@index([adminId])
  @@index([action])
  @@index([targetType])
  @@index([createdAt])
}
```

---

## üîß API PATRONEN

### Prisma Client Singleton

```typescript
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

### Auth Utilities

```typescript
// src/lib/auth.ts
import { cookies } from 'next/headers';
import { prisma } from './prisma';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET!;

export interface SessionUser {
  id: string;
  email: string;
  name: string;
  role: 'customer' | 'admin' | 'super_admin';
}

export async function getServerSession(): Promise<{ user: SessionUser } | null> {
  const cookieStore = await cookies();
  const token = cookieStore.get('auth-token')?.value;
  
  if (!token) return null;
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };
    
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
      },
    });
    
    if (!user || !user.isActive) return null;
    
    return { user: user as SessionUser };
  } catch {
    return null;
  }
}

export async function requireAuth() {
  const session = await getServerSession();
  if (!session) {
    throw new Error('Unauthorized');
  }
  return session;
}

export async function requireAdmin() {
  const session = await requireAuth();
  if (session.user.role !== 'admin' && session.user.role !== 'super_admin') {
    throw new Error('Forbidden');
  }
  return session;
}
```

### API Route with Full Protection

```typescript
// src/app/api/portal/[resource]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { getServerSession } from '@/lib/auth';
import { rateLimit } from '@/lib/rate-limit';

// Schema
const CreateSchema = z.object({
  subject: z.string().min(5, 'Onderwerp is te kort'),
  description: z.string().min(20, 'Beschrijving is te kort'),
  category: z.enum(['general', 'technical', 'billing', 'feature-request']),
  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  productId: z.string().optional(),
});

// GET - List user's items
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json({ error: 'Niet ingelogd' }, { status: 401 });
    }
    
    // Fetch user's data only
    const items = await prisma.supportTicket.findMany({
      where: { userId: session.user.id },
      orderBy: { createdAt: 'desc' },
      include: {
        product: { select: { name: true } },
        _count: { select: { messages: true } },
      },
    });
    
    return NextResponse.json(items);
    
  } catch (error) {
    console.error('GET Error:', error);
    return NextResponse.json({ error: 'Er ging iets mis' }, { status: 500 });
  }
}

// POST - Create new item
export async function POST(request: NextRequest) {
  try {
    // Rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const { success } = await rateLimit(ip, 10, 60);
    if (!success) {
      return NextResponse.json(
        { error: 'Te veel verzoeken' },
        { status: 429 }
      );
    }
    
    // Auth check
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json({ error: 'Niet ingelogd' }, { status: 401 });
    }
    
    // Validate input
    const body = await request.json();
    const data = CreateSchema.parse(body);
    
    // Generate ticket number
    const count = await prisma.supportTicket.count();
    const year = new Date().getFullYear();
    const ticketNumber = `RT-${year}-${String(count + 1).padStart(3, '0')}`;
    
    // Create ticket
    const ticket = await prisma.supportTicket.create({
      data: {
        ticketNumber,
        userId: session.user.id,
        ...data,
      },
    });
    
    return NextResponse.json(ticket, { status: 201 });
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validatie mislukt', details: error.errors },
        { status: 400 }
      );
    }
    
    console.error('POST Error:', error);
    return NextResponse.json({ error: 'Er ging iets mis' }, { status: 500 });
  }
}
```

### Admin API Route

```typescript
// src/app/api/admin/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAdmin } from '@/lib/auth';

export async function GET(request: NextRequest) {
  try {
    const session = await requireAdmin();
    
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    
    const where = search
      ? {
          OR: [
            { name: { contains: search } },
            { email: { contains: search } },
            { companyName: { contains: search } },
          ],
        }
      : {};
    
    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          email: true,
          name: true,
          companyName: true,
          role: true,
          isActive: true,
          createdAt: true,
          _count: {
            select: {
              subscriptions: true,
              products: true,
            },
          },
        },
      }),
      prisma.user.count({ where }),
    ]);
    
    // Log admin action
    await prisma.adminAuditLog.create({
      data: {
        adminId: session.user.id,
        adminEmail: session.user.email,
        action: 'users.list',
        targetType: 'user',
      },
    });
    
    return NextResponse.json({
      data: users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    });
    
  } catch (error) {
    if (error instanceof Error && error.message === 'Forbidden') {
      return NextResponse.json({ error: 'Geen toegang' }, { status: 403 });
    }
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Niet ingelogd' }, { status: 401 });
    }
    
    console.error('Admin GET Error:', error);
    return NextResponse.json({ error: 'Er ging iets mis' }, { status: 500 });
  }
}
```

### Stripe Webhook

```typescript
// src/app/api/subscriptions/webhook/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';
import Stripe from 'stripe';
import { prisma } from '@/lib/prisma';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(request: NextRequest) {
  const body = await request.text();
  const headersList = await headers();
  const signature = headersList.get('stripe-signature')!;
  
  let event: Stripe.Event;
  
  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed');
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
  }
  
  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription;
        
        await prisma.subscription.upsert({
          where: { stripeSubscriptionId: subscription.id },
          update: {
            status: subscription.status === 'active' ? 'active' : 'past_due',
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000),
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
          },
          create: {
            stripeSubscriptionId: subscription.id,
            stripeCustomerId: subscription.customer as string,
            userId: subscription.metadata.userId,
            planType: subscription.metadata.planType,
            planName: subscription.metadata.planName,
            monthlyPrice: (subscription.items.data[0].price.unit_amount || 0) / 100,
            currentPeriodStart: new Date(subscription.current_period_start * 1000),
            currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          },
        });
        break;
      }
      
      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        
        await prisma.subscription.update({
          where: { stripeSubscriptionId: subscription.id },
          data: {
            status: 'cancelled',
            cancelledAt: new Date(),
          },
        });
        break;
      }
      
      case 'invoice.paid': {
        const invoice = event.data.object as Stripe.Invoice;
        
        if (invoice.subscription) {
          await prisma.invoice.create({
            data: {
              stripeInvoiceId: invoice.id,
              userId: invoice.metadata?.userId || '',
              invoiceNumber: `RT-INV-${new Date().getFullYear()}-${invoice.number}`,
              amount: invoice.amount_paid / 100,
              tax: (invoice.tax || 0) / 100,
              status: 'paid',
              paidAt: new Date(),
              pdfUrl: invoice.invoice_pdf,
            },
          });
        }
        break;
      }
    }
    
    return NextResponse.json({ received: true });
    
  } catch (error) {
    console.error('Webhook processing error:', error);
    return NextResponse.json({ error: 'Processing failed' }, { status: 500 });
  }
}
```

---

## üîí SECURITY PATTERNS

### Rate Limiting

```typescript
// src/lib/rate-limit.ts
const rateLimitStore = new Map<string, { count: number; resetAt: number }>();

export async function rateLimit(
  identifier: string,
  limit: number = 10,
  windowSeconds: number = 60
): Promise<{ success: boolean; remaining: number }> {
  const now = Date.now();
  const windowMs = windowSeconds * 1000;
  
  const record = rateLimitStore.get(identifier);
  
  if (!record || now > record.resetAt) {
    rateLimitStore.set(identifier, { count: 1, resetAt: now + windowMs });
    return { success: true, remaining: limit - 1 };
  }
  
  if (record.count >= limit) {
    return { success: false, remaining: 0 };
  }
  
  record.count++;
  return { success: true, remaining: limit - record.count };
}
```

### Input Sanitization

```typescript
// Always use Zod for validation
import { z } from 'zod';

// Safe string (no HTML)
const safeString = z.string().transform(s => 
  s.replace(/<[^>]*>/g, '').trim()
);

// Email with normalization
const normalizedEmail = z.string().email().transform(e => 
  e.toLowerCase().trim()
);

// Phone number (Dutch format)
const dutchPhone = z.string().regex(
  /^(\+31|0)[1-9][0-9]{8}$/,
  'Ongeldig telefoonnummer'
);
```

---

## üöÄ DATABASE COMMANDS

```bash
# Push schema changes (development)
npm run db:push

# Open Prisma Studio
npm run db:studio

# Seed database
npm run db:seed

# Create admin user
npm run admin:create

# Generate Prisma Client
npx prisma generate

# Reset database (DANGER)
npx prisma db push --force-reset
```

---

## ‚ö†Ô∏è ANTI-PATTERNS

```typescript
// ‚ùå NOOIT: User data zonder auth check
const users = await prisma.user.findMany();

// ‚úÖ ALTIJD: Auth + scope check
const session = await requireAuth();
const myData = await prisma.product.findMany({
  where: { userId: session.user.id }
});

// ‚ùå NOOIT: Raw queries met user input
await prisma.$queryRaw`SELECT * FROM users WHERE email = ${email}`;

// ‚úÖ ALTIJD: Prisma's built-in escaping
await prisma.user.findUnique({ where: { email } });

// ‚ùå NOOIT: Passwords in responses
return NextResponse.json(user);

// ‚úÖ ALTIJD: Exclude sensitive fields
const { password, ...safeUser } = user;
return NextResponse.json(safeUser);

// ‚ùå NOOIT: Unvalidated input direct naar database
await prisma.user.create({ data: body });

// ‚úÖ ALTIJD: Zod validatie eerst
const validated = CreateUserSchema.parse(body);
await prisma.user.create({ data: validated });
```
